mads 1.9.3
     1 FFFF> 02E0-02E1> 19 3C				run start
     2
     3 = 004D						ATTRACT = $4d
     4 = 02FC						CH = $2fc
     5 = D010						TRIG0 = $d010
     6 = D011						TRIG1 = $d011
     7 = D200						AUDF1 = $d200
     8 = D201						AUDC1 = $d201
     9 = D203						AUDC2 = $d203
    10 = D205						AUDC3 = $d205
    11 = D207						AUDC4 = $d207
    12
    13 = D208						AUDCTL = $d208
    14 = D20F						SKCTL = $d20f
    15
    16 = 4F00						ADSRStart = $4f00
    17 = 4F05						ADSRTable = ADSRStart+5
    18
    19 02E2						org $CB
    20
    21 00CB-00D1> 00 99		NOTEPTR		.word $9900			; change this to end of notes
    22 00CD 00 50		PLAYPTR		.word $5000			; change this to beginning of notes
    23 00CF 00 00		PLAYTIMER	.word 0
    24 00D1 00			TIMER		.byte 0
    25
    26 00D2						org $3c00
    27
    28 3C00-3E0C> 68					pla					; BASIC routine to pull beginning and length of notes
    29 3C01 C9 02					cmp #2				; usage: X=USR(16384,PLAYPTR,NOTEPTR) (see above)
    30 3C03 F0 08					beq pulldata
    31 3C05 A8						tay					; not exactly 2 arguments, so exit, but do leave with a proper stack...
    32 3C06 88						dey
    33 3C07 68			clearstack	pla
    34 3C08 68						pla
    35 3C09 88						dey
    36 3C0A 10 FB					bpl clearstack
    37 3C0C 60						rts
    38
    39 3C0D 68			pulldata	pla
    40 3C0E 85 CE					sta PLAYPTR+1
    41 3C10 68						pla
    42 3C11 85 CD					sta PLAYPTR
    43 3C13 68						pla 
    44 3C14 85 CC					sta NOTEPTR+1
    45 3C16 68						pla 
    46 3C17 85 CB					sta NOTEPTR
    47
    48 3C19			start
    49 3C19 A5 CD					lda PLAYPTR
    50 3C1B 8D E8 3D					sta TEMPPTR
    51 3C1E A5 CE					lda PLAYPTR+1
    52 3C20 8D E9 3D					sta TEMPPTR+1
    53 							
    54 3C23 A0 22					ldy #<VBI				; set up VBI
    55 3C25 A2 3D					ldx #>VBI
    56 3C27 A9 06					lda #6
    57 3C29 20 5C E4					jsr $e45c
    58
    59 3C2C A9 03					lda #3
    60 3C2E 8D 0F D2					sta SKCTL
    61 3C31 A9 00					lda #0
    62 3C33 8D 08 D2					sta AUDCTL
    63 3C36 85 14					sta 20
    64 							
    65 3C38 A0 03					ldy #3
    66 3C3A 99 DE 3D		cleartimer	sta NOTETIMER,y
    67 3C3D 88						dey
    68 3C3E 10 FA					bpl cleartimer
    69
    70 3C40			playloop	
    71 3C40 38						sec
    72 3C41 A5 14					lda 20
    73 3C43 E5 D1					sbc TIMER
    74 3C45 F0 F9					beq playloop
    75 3C47 A5 14					lda 20
    76 3C49 85 D1					sta TIMER
    77 3C4B A9 00					lda #0
    78 3C4D 85 4D					sta ATTRACT
    79
    80 3C4F EE DE 3D					inc NOTETIMER			; increase timer
    81 3C52 D0 03					bne donetimer0
    82 3C54 EE DF 3D					inc NOTETIMER+1
    83 3C57 EE E0 3D		donetimer0	inc NOTETIMER+2
    84 3C5A D0 03					bne donetimer1
    85 3C5C EE E1 3D					inc NOTETIMER+3
    86 3C5F EE E2 3D		donetimer1	inc NOTETIMER+4
    87 3C62 D0 03					bne donetimer2
    88 3C64 EE E3 3D					inc NOTETIMER+5
    89 3C67 EE E4 3D		donetimer2	inc NOTETIMER+6
    90 3C6A D0 03					bne exitcond
    91 3C6C EE E5 3D					inc NOTETIMER+7
    92 							
    93 3C6F AD FC 02		exitcond	lda CH					; define an exit condition - here: SPACE key
    94 3C72 C9 21					cmp #$21
    95 3C74 D0 03					bne contcheck
    96 3C76 4C 08 3D		jmpexitp	jmp exitplay
    97 3C79 A5 CE		contcheck	lda PLAYPTR+1			; check end of music
    98 3C7B C5 CC					cmp NOTEPTR+1
    99 3C7D 90 06					bcc doplay
   100 3C7F A5 CD					lda PLAYPTR
   101 3C81 C5 CB					cmp NOTEPTR
   102 3C83 B0 F1					bcs jmpexitp
   103
   104 3C85 A0 00		doplay		ldy #0
   105 3C87 B1 CD					lda (PLAYPTR),y
   106 3C89 AA						tax						; voice to X
   107 3C8A C8						iny
   108 3C8B B1 CD					lda (PLAYPTR),y
   109 3C8D 8D E6 3D					sta PLAYAUDC			; save AUDC-value
   110 3C90 C8						iny
   111 3C91 B1 CD					lda (PLAYPTR),y
   112 3C93 8D E7 3D					sta PLAYNOTE			; save note
   113 3C96 C8						iny
   114 3C97 B1 CD					lda (PLAYPTR),y
   115 3C99 85 CF					sta PLAYTIMER			; save timer low-byte
   116 3C9B C8						iny
   117 3C9C B1 CD					lda (PLAYPTR),y
   118 3C9E 85 D0					sta PLAYTIMER+1			; save timer high-byte
   119
   120 3CA0 BD EA 3D					lda POKEYOffset,x
   121 3CA3 A8						tay						; Offset to Y
   122 3CA4 B9 DF 3D		waittimer	lda NOTETIMER+1,y
   123 3CA7 C5 D0					cmp PLAYTIMER+1			; Playtimer >= Notetimer (high byte)?
   124 3CA9 90 95					bcc playloop
   125 3CAB B9 DE 3D					lda NOTETIMER,y
   126 3CAE C5 CF					cmp PLAYTIMER			; Playtimer >= Notetimer (low byte)?
   127 3CB0 90 8E					bcc playloop
   128 3CB2 A9 00					lda #0					; First reset counters...
   129 3CB4 85 CF					sta PLAYTIMER
   130 3CB6 85 D0					sta PLAYTIMER+1
   131 3CB8 99 DE 3D					sta NOTETIMER,y
   132 3CBB 99 DF 3D					sta NOTETIMER+1,y
   133 3CBE AD E6 3D					lda PLAYAUDC			; then play note...
   134 3CC1 29 F0					and #%11110000
   135 3CC3 9D F2 3D					sta AC1,x
   136 3CC6 A9 01					lda #1
   137 3CC8 9D 02 3E					sta ADSRActive,x
   138 3CCB AD E6 3D					lda PLAYAUDC
   139 3CCE 29 0F					and #%00001111
   140
   141 3CD0 48						pha
   142 3CD1 C9 00					cmp #0				; Voice off, begin release phase?
   143 3CD3 D0 12					bne contADS
   144 3CD5 98						tya
   145 3CD6 48						pha
   146 3CD7 BC 00 4F					ldy ADSRStart,x
   147 3CDA B9 05 4F					lda ADSRTable,y
   148 3CDD 18						clc
   149 3CDE 69 01					adc #1
   150 				;			lda RelOffset,x		; set beginning of release phase values
   151 3CE0 9D EE 3D					sta ADSRC,x			; to counter
   152 3CE3 68						pla
   153 3CE4 A8						tay
   154 3CE5 10 05					bpl contplay
   155 3CE7 A9 01		contADS		lda #1
   156 3CE9 9D EE 3D					sta ADSRC,x
   157 3CEC 68			contplay	pla
   158
   159 3CED 9D F6 3D					sta VOLSAVE,x
   160 				;			sta AUDC1,y
   161 3CF0 AD E7 3D					lda PLAYNOTE
   162 3CF3 99 00 D2					sta AUDF1,y
   163
   164 3CF6 18						clc
   165 3CF7 A5 CD					lda PLAYPTR
   166 3CF9 69 05					adc #$05				; increase pointer
   167 3CFB 85 CD					sta PLAYPTR
   168 3CFD 90 06					bcc jmpexitc
   169 3CFF A5 CE					lda PLAYPTR+1
   170 3D01 69 00					adc #0
   171 3D03 85 CE					sta PLAYPTR+1
   172 3D05 4C 6F 3C		jmpexitc	jmp exitcond
   173 							
   174 3D08 A0 5F		exitplay	ldy #$5f			; disable VBI
   175 3D0A A2 E4					ldx #$e4
   176 3D0C A9 06					lda #6
   177 3D0E 20 5C E4					jsr $e45c
   178
   179 3D11 A0 03					ldy #3
   180 3D13 A9 00					lda #0
   181 3D15 99 DE 3D		clearplayer	sta NOTETIMER,y
   182 3D18 99 01 D2					sta AUDC1,y
   183 3D1B 99 05 D2					sta AUDC1+4,y
   184 3D1E 88						dey
   185 3D1F 10 F4					bpl clearplayer
   186 3D21 60						rts
   187
   188 3D22 A2 00		VBI			ldx #0
   189 3D24 BD 02 3E		nextadsr	lda ADSRActive,x	; are we in ADSR mode?
   190 3D27 D0 03					bne nextadsr2		; if not then next voice
   191 3D29 4C D1 3D					jmp nextx
   192 3D2C BD F6 3D		nextadsr2	lda VOLSAVE,x		; get channel's volume
   193 3D2F 48						pha					; save volume
   194 3D30 8A						txa					; channel no. from X to A 
   195 3D31 BD 00 4F					lda ADSRStart,x
   196 3D34 18						clc
   197 3D35 7D EE 3D					adc ADSRC,x			; add counter to create final pointer
   198 3D38 A8						tay					; store pointer in Y
   199 3D39 8D 08 3E					sta ADSRTemp		; and in temp variable
   200 3D3C B9 05 4F					lda ADSRTable,y		; mask DistEnv
   201 3D3F 48						pha
   202 3D40 29 0F					and #%00001111
   203 3D42 8D 06 3E					sta ADSRVol
   204 3D45 68						pla
   205 3D46 29 F0					and #%11110000
   206 3D48 8D 07 3E					sta ADSRDist
   207 3D4B 68						pla					; get back volume
   208
   209 3D4C C9 00					cmp #0				; are we in release phase
   210 3D4E D0 0F					bne adsphase
   211 3D50 18			relphase	clc					; yes, then add value to current sound level (zero)
   212 				;			adc ADSRTable,y
   213 3D51 6D 06 3E					adc ADSRVol
   214 3D54 DD FA 3D					cmp VOLTemp,x
   215 3D57 90 14					bcc setadsr
   216 3D59 BD FA 3D					lda VOLTemp,x
   217 3D5C 4C 6D 3D					jmp setadsr
   218
   219 3D5F 38			adsphase	sec					; otherwise, in ADS mode:
   220 				;			sbc ADSRTable,y		; subtract envelope
   221 3D60 ED 06 3E					sbc ADSRVol
   222 3D63 9D FA 3D					sta VOLTemp,x		; remember last volume level for possible release phase
   223 3D66 B0 05					bcs setadsr			; less than zero?
   224 3D68 A9 00					lda #0				; then zero it is.
   225 3D6A 9D FA 3D					sta VOLTemp,x
   226 3D6D 48			setadsr		pha					; save volume to stack
   227 3D6E 9D FE 3D					sta DispVol,x
   228 3D71 AD 07 3E					lda ADSRDist		; test DistEnv
   229 3D74 D0 08					bne DistEnv
   230 3D76 68						pla
   231 3D77 18						clc
   232 3D78 7D F2 3D					adc AC1,x			; either add standard distortion
   233 3D7B 4C 83 3D					jmp storeAUDC
   234 3D7E 68			DistEnv		pla
   235 3D7F 18						clc
   236 3D80 6D 07 3E					adc ADSRDist		; or add distortion from envelope
   237 				;			lda VOLTemp,x
   238 				;			clc
   239 				;			adc AC1,x			; add distortion
   240 3D83 48			storeAUDC	pha					; save resulting AUDC value
   241 				;			lda POKEYOffset,x	; find out where to store it
   242 3D84 8A						txa
   243 3D85 0A						asl
   244 3D86 A8						tay
   245 3D87 68						pla
   246 3D88 99 01 D2					sta AUDC1,y			; and play
   247
   248 3D8B BD 01 4F					lda ADSRStart+1,x
   249 3D8E 38						sec
   250 3D8F FD 00 4F					sbc ADSRStart,x
   251 3D92 9D 09 3E					sta RelMax,x
   252 3D95 BD EE 3D					lda ADSRC,x			; increase envelope counter
   253 3D98 18						clc
   254 3D99 69 01					adc #1
   255 3D9B DD 09 3E					cmp RelMax,x		; if in release mode
   256 3D9E B0 1E					bcs resetADSR		; check for end of release
   257 3DA0 BC 00 4F					ldy ADSRStart,x
   258 3DA3 D9 05 4F					cmp ADSRTable,y		; otherwise, is ADS stage maxed out?
   259 3DA6 D0 10					bne incADSRC		; if not then increase
   260
   261 3DA8 AD 08 3E					lda ADSRTemp		; get back current counter
   262 3DAB A8						tay
   263 3DAC C8						iny					; increase
   264 3DAD B9 05 4F					lda ADSRTable,y
   265 3DB0 F0 1F					beq nextx			; if zero then remain at last position
   266 3DB2 BD EE 3D					lda ADSRC,x			; otherwise
   267 3DB5 F9 05 4F					sbc ADSRTable,y		; subtract offset byte (pos. ADSRMax)
   268 3DB8 9D EE 3D		incADSRC	sta ADSRC,x			; and set counter accordingly
   269 3DBB 4C D1 3D					jmp nextx
   270
   271 3DBE A9 01		resetADSR	lda #1
   272 3DC0 9D EE 3D					sta ADSRC,x
   273 3DC3 A9 00					lda #0
   274 3DC5 9D 02 3E					sta ADSRActive,x
   275 3DC8 8D 06 3E					sta ADSRVol
   276 3DCB 8D 07 3E					sta ADSRDist
   277 3DCE 9D FA 3D					sta VolTemp,x
   278
   279 3DD1 E8			nextx		inx
   280 3DD2 E0 04					cpx #4
   281 3DD4 D0 03					bne jmpnexta
   282 3DD6 4C 5F E4					jmp $e45f
   283 3DD9 4C 24 3D		jmpnexta	jmp nextadsr
   284
   285 3DDC 00 00		NOTE		.byte 0, 0
   286 3DDE 00 00 00 00 00 00 + NOTETIMER	.word 0, 0, 0, 0
   287 3DE6 00			PLAYAUDC	.byte 0
   288 3DE7 00			PLAYNOTE	.byte 0
   289 3DE8 00 00		TEMPPTR		.word 0
   290
   291 3DEA 00 02 04 06		POKEYOffset	.byte 0, 2, 4, 6
   292 				;RelOffset	.byte $30, $70, $b0, $f0	; these can be adjusted if you need a longer release phase at the cost of shorter ADS phase
   293 				;RelMax		.byte $40, $80, $c0, $00
   294 3DEE 00 00 00 00		ADSRC		.byte 0, 0, 0, 0
   295 3DF2 A0 A0 A0 A0		AC1			.byte $a0, $a0, $a0, $a0
   296 3DF6 00 00 00 00		VOLSAVE		.byte 0, 0, 0, 0
   297 3DFA 00 00 00 00		VolTemp		.byte 0, 0, 0, 0
   298 3DFE 00 00 00 00		DispVol		.byte 0, 0 ,0 ,0
   299 3E02 00 00 00 00		ADSRActive	.byte 0, 0, 0 ,0
   300 3E06 00			ADSRVol		.byte 0
   301 3E07 00			ADSRDist	.byte 0
   302 3E08 00			ADSRTemp	.byte 0
   303 3E09 00 00 00 00		RelMax		.byte 0, 0, 0, 0
